
#' Build TMB object for geostatistical delta-GLMM
#'
#' \code{Build_TMB_Fn} builds a tagged list with everything necessary to run or interpret inputs for \code{SpatialVAM}
#'
#' @param TmbbData, a tagged list of data inputs generated by \code{Data_Fn}
#' @inheritParams Data_Fn
#' @param Use_REML, OPTIONAL boolean whether to use maximum marginal likelihood or restricted maximum likelihood (termed "REML")
#' @param estimate_phi, Estimate the multiplicative offset between initial and equilibrium density
#' @param Kappa, controls kappa (decorrelation distance) of spatial variation in productivity among species, as well as the spatio-temporal "process error"
#' \describe{
#'   \item{"constant"}{Same value for all spatial plus the spatio-temporal component}
#'   \item{"spatial_vs_spatiotemporal"}{Same value for all spatial, but different for the spatio-temporal component}
#'   \item{"different"}{Different for all spatial components as well as the spatio-temporal component}
#' }
#' @param Parameters OPTIONAL, a tagged list of starting parameters
#' @param Random OPTIONAL, a character vector of random effects
#' @param Map OPTIONAL, a tagged list of parameters to either mirror or turn off
#' @param Use_REML, OPTIONAL boolean whether to use maximum marginal likelihood or restricted maximum likelihood (termed "REML")
#' @param loc_x OPTIONAL, location for each sample used to generate plausible bounds for scale parameter
#' @param eigenbounds upper and lower bounds for the estimated eigenvalues of the community matrix
#' @param TmbDir OPTIONAL, a directory where the CPP file for the VAST model can be found locally
#' @param RunDir OPTIONAL, a directory where the CPP file is copied, copiled, and run (must have write privileges or else the function will crash)
#' @param silent Boolean, whether TMB should run silently

#' @return Tagged list containing objects for running a VAST model
#' \describe{
#'   \item{Obj}{The built TMB object}
#'   \item{Upper}{A vector of upper bounds for parameters, optionally for use during optimization}
#'   \item{Lower}{A vector of lower bounds for parameters, optionally for use during optimization}
#'   \item{Parameters}{A tagged list of parameter starting values used when building Obj, which can be extracted, modified, and then put back into \code{Build_TMB_Fn} to define different starting values}
#'   \item{Map}{A taggged list of parameters to be turned off or mirrored, for similar use as Parameters}
#'   \item{Random}{A character vector of random effects, for similar use as Parameters}
#' }

#' @export
Build_TMB_Fn = function( TmbData, Version, estimate_phi=TRUE, Kappa="constant", Parameters="generate",
  Random="generate", Map="generate", use_REML=FALSE, loc_x=NULL, eigenbounds = c("Lower"=-2,"Upper"=-0.01),
  TmbDir=system.file("executables",package="SpatialVAM"), RunDir=getwd() ){

  # Local functions
  rmatrix = function(nrow, ncol, mean=0, sd=1, diag=NA){
    Return = matrix(rnorm(nrow*ncol,mean=mean,sd=sd), nrow=nrow, ncol=ncol)
    if( !is.na(diag)) Return[cbind(1:min(nrow,ncol),1:min(nrow,ncol))] = diag
    return(Return)
  }
  seq_pos = function( n ) seq(from=1, to=n, length=n)
  boundsifpresent_fn = function( par, map, name, lower, upper, bounds ){
    if( name %in% names(par) ){
      bounds[grep(name,names(par)),c('Lower','Upper')] = c(lower,upper)
    }
    return( bounds )
  }


  # Compile TMB software
  #dyn.unload( paste0(RunDir,"/",dynlib(TMB:::getUserDLL())) ) # random=Random,
  file.copy( from=paste0(TmbDir,"/",Version,".cpp"), to=paste0(RunDir,"/",Version,".cpp"), overwrite=FALSE)
  setwd( RunDir )
  compile( paste0(Version,".cpp") )

  # Bounds on distances
  if( !is.null(loc_x) ){
    Dist = stats::dist(loc_x)
    MinDist = log(sqrt(8)/max(Dist)) # Range = nu*sqrt(8)/kappa
    MaxDist = log(sqrt(8)/min(Dist)) # Range = nu*sqrt(8)/kappa
    MidDist = mean( c(MinDist,MaxDist) )
  }else{
    MinDist = -Inf
    MaxDist = Inf
    MidDist = 0
  }

  # Inputs for nonspatial model
  if( Version%in%c("nonspatial_vam_v3","nonspatial_vam_v2","nonspatial_vam_v1")){

    # Parameters
    if(Version%in%c("nonspatial_vam_v2","nonspatial_vam_v1")) TmbParams = list("alpha_p"=rep(0,TmbData$n_p), "phi_p"=rep(0,TmbData$n_p), "L_val"=rnorm(TmbData$n_j*TmbData$n_p-TmbData$n_j*(TmbData$n_j-1)/2), "B_pp"=matrix(rnorm(TmbData$n_p^2,sd=0.1),TmbData$n_p,TmbData$n_p), "logsigma_pz"=matrix(0,nrow=TmbData$n_p,2), "d_tp"=array(2,dim=unlist(Data[c('n_t','n_p')])))
    if(Version%in%c("nonspatial_vam_v3")) TmbParams = list("alpha_p"=rep(0,TmbData$n_p), "phi_p"=rep(0,TmbData$n_p), "L_val"=rnorm(TmbData$n_j*TmbData$n_p-TmbData$n_j*(TmbData$n_j-1)/2), "Alpha_pr"=rbind(diag(-0.5,TmbData$n_r),rmatrix(nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r,sd=0.01)), "Beta_pr"=rbind(diag(TmbData$n_r),rmatrix(nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r,sd=0.2)), "logsigma_pz"=matrix(0,nrow=TmbData$n_p,2), "d_tp"=array(2,dim=unlist(Data[c('n_t','n_p')])))

    # Random
    if( length(Random)==1 && Random=="generate" ){
      Random = c( "d_tp" )
      if(use_REML==TRUE) Random = c(Random, "alpha_p", "phi_p")  # , "B_pp"
    }

    # Map
    if( length(Map)==1 && Map=="generate" ){
      Map = NULL
      # fix phi
      if( estimate_phi==FALSE ){
        Map[["phi_p"]] = factor( rep(NA,length(TmbParams[["phi_p"]])) )
        TmbParams[["phi_p"]][] = 0
      }
      # Fix Alpha_pr and Beta_pr for the eigendecomposition method
      if( TmbData$Options_vec[["B_type"]] %in% c(1) ){
        # Alpha_pr, fix first row at one, so that the magnitude of each eigenvector is not colinear with the eigenvalues
        Map[["Alpha_pr"]] = array(1:prod(dim(TmbParams[["Beta_pr"]])), dim=dim(TmbParams[["Beta_pr"]]))
        Map[["Alpha_pr"]][1,] = NA
        Map[["Alpha_pr"]] = factor(Map[["Alpha_pr"]])
        # Beta_pr, just estimate row column, which is interpreted as eigenvalues
        Map[["Beta_pr"]] = array(NA, dim=dim(TmbParams[["Beta_pr"]]))
        Map[["Beta_pr"]][1,] = 1:ncol(Map[["Beta_pr"]])
        Map[["Beta_pr"]] = factor(Map[["Beta_pr"]])
        TmbParams[["Alpha_pr"]] = array( ifelse(!is.na(Map[["Alpha_pr"]]),TmbParams[["Alpha_pr"]],1), dim=dim(TmbParams[["Alpha_pr"]]))
        TmbParams[["Beta_pr"]] = array( ifelse(!is.na(Map[["Beta_pr"]]),-0.5,0), dim=dim(TmbParams[["Beta_pr"]]))  # B = U%*%L%*%solve(U) + I_pp, so -1<=eigenvalues<=0
      }
      # Identifiability restrictions on Beta_pr for co-integration method
      if( "Beta_pr"%in%names(TmbParams) && TmbData$Options_vec[["B_type"]]%in%c(0,2,4) ){
        Map[["Beta_pr"]] = factor(rbind( matrix(NA,nrow=TmbData$n_r,ncol=TmbData$n_r), matrix(seq_pos(TmbData$n_r*(TmbData$n_p-TmbData$n_r)),nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r)))
      }
      # Better initial conditions for eigen-cointegration
      if( "Alpha_pr"%in%names(TmbParams) && TmbData$Options_vec[["B_type"]]%in%c(2) ){
        TmbParams[["Alpha_pr"]][1,] = -0.5
      }
      # Make B_pp diagonal
      if( TmbData$Options_vec[["independentTF"]]==TRUE ){
        if( "B_pp" %in% names(TmbParams) ){
          Map[["B_pp"]] = matrix(NA, nrow=TmbData$n_p, ncol=TmbData$n_p)
          diag(Map[["B_pp"]]) = 1:TmbData$n_p
          Map[["B_pp"]] = factor( Map[["B_pp"]] )
          TmbParams[["B_pp"]][] = 0
          TmbParams[["L_val"]][] = 0
        }
        if( "Alpha_pr"%in%names(TmbParams) && TmbData$n_r==TmbData$n_p ){
          Map[["Alpha_pr"]] = matrix(NA, nrow=TmbData$n_p, ncol=TmbData$n_p)
          diag(Map[["Alpha_pr"]]) = 1:TmbData$n_p
          Map[["Alpha_pr"]] = factor( Map[["Alpha_pr"]] )
          TmbParams[["Alpha_pr"]][] = 0
          TmbParams[["L_val"]][] = 0
        }
      }
      # Observation model
      Map[["logsigma_pz"]] = matrix( 1:(2*TmbData$n_p), ncol=2, byrow=TRUE )
      for(p in 1:TmbData$n_p){
        if( TmbData$ObsModel_p[p]==0 ){
          Map[["logsigma_pz"]][p,] = c(NA,NA)
        }
        if( TmbData$ObsModel_p[p] %in% c(1,3,4) ){
          Map[["logsigma_pz"]][p,2] = NA
        }
      }
      Map[["logsigma_pz"]] = factor( Map[["logsigma_pz"]] )
    }

    # Decide about user-supplied or generated Parameters
    if( length(Parameters)==1 && Parameters=="generate" ){
      Parameters = TmbParams
    }
  } # End nonspatial

  # Inputs for Spatial model
  if( Version%in%c("spatial_vam_v15","spatial_vam_v14","spatial_vam_v13","spatial_vam_v12","spatial_vam_v11","spatial_vam_v10","spatial_vam_v9","spatial_vam_v8","spatial_vam_v7","spatial_vam_v6","spatial_vam_v5","spatial_vam_v4","spatial_vam_v3","spatial_vam_v2","spatial_vam_v1")){
    # Parameters
    if(Version=="spatial_vam_v1") TmbParams = list("Hinput_z"=c(0,0), "logkappa"=MidDist, "alpha_p"=rep(0,TmbData$n_p), "phi_p"=rep(0,TmbData$n_p), "logtauA_p"=rep(0,TmbData$n_p), "L_val"=rnorm(TmbData$n_j*TmbData$n_p-TmbData$n_j*(TmbData$n_j-1)/2), "B_pp"=matrix(rnorm(TmbData$n_p^2,sd=0.1),TmbData$n_p,TmbData$n_p), "d_ktp"=array(2,dim=unlist(Data[c('n_k','n_t','n_p')])), "Ainput_kp"=matrix(0,nrow=TmbData$n_k,ncol=TmbData$n_p))
    if(Version%in%c("spatial_vam_v3","spatial_vam_v2")) TmbParams = list("Hinput_z"=c(0,0), "logkappa"=MidDist, "alpha_p"=rep(0,TmbData$n_p), "phi_p"=rep(0,TmbData$n_p), "logtauA_p"=rep(0,TmbData$n_p), "L_val"=ifelse( is.na(SpatialVAM:::fixdiag(Nrow=TmbData$n_p, Ncol=TmbData$n_j)), 1, 0), "B_pp"=diag(0.5,TmbData$n_p), "logsigma_pz"=matrix(0,nrow=TmbData$n_p,1), "d_ktp"=abind::abind(SimList$d_stp,array(0,dim=c(TmbData$n_k-TmbData$n_s,TmbData$n_t,TmbData$n_p)),along=1), "Ainput_kp"=matrix(0,nrow=TmbData$n_k,ncol=TmbData$n_p))      # "d_ktp"=array(2,dim=unlist(Data[c('n_k','n_t','n_p')]))
    if(Version%in%c("spatial_vam_v4")) TmbParams = list("Hinput_z"=c(0,0), "logkappa"=MidDist, "alpha_p"=rep(0,TmbData$n_p), "phi_p"=rep(0,TmbData$n_p), "logtauA_p"=rep(0,TmbData$n_p), "L_val"=ifelse( is.na(SpatialVAM:::fixdiag(Nrow=TmbData$n_p, Ncol=TmbData$n_j)), 1, 0), "B_pp"=diag(0.5,TmbData$n_p), "logsigma_pz"=matrix(0,nrow=TmbData$n_p,2), "d_ktp"=array(0,dim=c(TmbData$n_k,TmbData$n_t,TmbData$n_p)), "Ainput_kp"=matrix(0,nrow=TmbData$n_k,ncol=TmbData$n_p))      # "d_ktp"=array(2,dim=unlist(Data[c('n_k','n_t','n_p')]))
    if(Version%in%c("spatial_vam_v7","spatial_vam_v6","spatial_vam_v5")) TmbParams = list("Hinput_z"=c(0,0), "logkappa"=MidDist, "alpha_p"=rep(0,TmbData$n_p), "phi_p"=rep(0,TmbData$n_p), "logtauA_p"=rep(0,TmbData$n_p), "L_val"=ifelse( is.na(SpatialVAM:::fixdiag(Nrow=TmbData$n_p, Ncol=TmbData$n_j)), 1, 0), "B_pp"=diag(0.5,TmbData$n_p), "logsigma_pz"=matrix(0,nrow=TmbData$n_p,2), "d_ktp"=array(0,dim=c(TmbData$n_k,TmbData$n_t,TmbData$n_p)), "Ainput_kp"=matrix(0,nrow=TmbData$n_k,ncol=TmbData$n_p), "delta_i"=rep(0,TmbData$n_i))      # "d_ktp"=array(2,dim=unlist(Data[c('n_k','n_t','n_p')]))
    if(Version%in%c("spatial_vam_v9","spatial_vam_v8")) TmbParams = list("Hinput_z"=c(0,0), "logkappa"=MidDist, "alpha_p"=rep(0,TmbData$n_p), "phi_p"=rep(0,TmbData$n_p), "logtauA_p"=rep(0,TmbData$n_p), "L_val"=ifelse( is.na(SpatialVAM:::fixdiag(Nrow=TmbData$n_p, Ncol=TmbData$n_j)), 1, 0), "Alpha_pr"=rbind(diag(-0.5,TmbData$n_r),rmatrix(nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r,sd=0.01)), "Beta_pr"=rbind(diag(TmbData$n_r),rmatrix(nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r,sd=0.2)), "logsigma_pz"=matrix(0,nrow=TmbData$n_p,2), "d_ktp"=array(0,dim=c(TmbData$n_k,TmbData$n_t,TmbData$n_p)), "Ainput_kp"=matrix(0,nrow=TmbData$n_k,ncol=TmbData$n_p), "delta_i"=rep(0,TmbData$n_i))      # "d_ktp"=array(2,dim=unlist(Data[c('n_k','n_t','n_p')]))
    if(Version%in%c("spatial_vam_v10")) TmbParams = list("Hinput_z"=c(0,0), "logkappa"=MidDist, "alpha_p"=rep(0,TmbData$n_p), "phi_p"=rep(0,TmbData$n_p), "logMargSigmaA_p"=rep(0,TmbData$n_p), "L_val"=ifelse( is.na(SpatialVAM:::fixdiag(Nrow=TmbData$n_p, Ncol=TmbData$n_j)), 1, 0), "Alpha_pr"=rbind(diag(-0.5,TmbData$n_r),rmatrix(nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r,sd=0.01)), "Beta_pr"=rbind(diag(TmbData$n_r),rmatrix(nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r,sd=0.2)), "logsigma_pz"=matrix(0,nrow=TmbData$n_p,2), "d_ktp"=array(0,dim=c(TmbData$n_k,TmbData$n_t,TmbData$n_p)), "Ainput_kp"=matrix(0,nrow=TmbData$n_k,ncol=TmbData$n_p), "delta_i"=rep(0,TmbData$n_i))      # "d_ktp"=array(2,dim=unlist(Data[c('n_k','n_t','n_p')]))
    if(Version%in%c("spatial_vam_v12","spatial_vam_v11")) TmbParams = list("Hinput_z"=c(0,0), "logkappa_z"=rep(MidDist,TmbData$n_p+1), "alpha_p"=rep(0,TmbData$n_p), "phi_p"=rep(0,TmbData$n_p), "logMargSigmaA_p"=rep(0,TmbData$n_p), "L_val"=ifelse( is.na(SpatialVAM:::fixdiag(Nrow=TmbData$n_p, Ncol=TmbData$n_j)), 1, 0), "Alpha_pr"=rbind(rmatrix(nrow=TmbData$n_r,ncol=TmbData$n_r,sd=0.01,diag=-0.5),rmatrix(nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r,sd=0.01)), "Beta_pr"=rbind(diag(TmbData$n_r),rmatrix(nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r,sd=0.2)), "logsigma_pz"=matrix(0,nrow=TmbData$n_p,2), "d_ktp"=array(0,dim=c(TmbData$n_k,TmbData$n_t,TmbData$n_p)), "Ainput_kp"=matrix(0,nrow=TmbData$n_k,ncol=TmbData$n_p), "delta_i"=rep(0,TmbData$n_i))      # "d_ktp"=array(2,dim=unlist(Data[c('n_k','n_t','n_p')]))
    if(Version%in%c("spatial_vam_v14","spatial_vam_v13")) TmbParams = list("Hinput_z"=c(0,0), "logkappa_z"=rep(MidDist,TmbData$n_p+1), "alpha_p"=rep(0,TmbData$n_p), "phi_p"=rep(0,TmbData$n_p), "logMargSigmaA_p"=rep(0,TmbData$n_p), "L_val"=ifelse( is.na(SpatialVAM:::fixdiag(Nrow=TmbData$n_p, Ncol=TmbData$n_j)), 1, 0), "Alpha_pr"=rbind(rmatrix(nrow=TmbData$n_r,ncol=TmbData$n_r,sd=0.01,diag=-0.5),rmatrix(nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r,sd=0.01)), "Beta_pr"=rbind(diag(TmbData$n_r),rmatrix(nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r,sd=0.2)), "logsigma_pz"=matrix(0,nrow=TmbData$n_p,2), "d_ktp"=array(0,dim=c(TmbData$n_k,TmbData$n_t,TmbData$n_p)), "Ainput_kp"=matrix(0,nrow=TmbData$n_k,ncol=TmbData$n_p), "delta_i"=rep(0,TmbData$n_i))      # "d_ktp"=array(2,dim=unlist(Data[c('n_k','n_t','n_p')]))
    if(Version%in%c("spatial_vam_v15")) TmbParams = list("Hinput_z"=c(0,0), "logkappa_z"=rep(MidDist,TmbData$n_p+1), "alpha_p"=rep(0,TmbData$n_p), "phi_p"=rep(0,TmbData$n_p), "logMargSigmaA_p"=rep(0,TmbData$n_p), "L_val"=ifelse( is.na(SpatialVAM:::fixdiag(Nrow=TmbData$n_p, Ncol=TmbData$n_j)), 1, 0), "Alpha_pr"=rbind(rmatrix(nrow=TmbData$n_r,ncol=TmbData$n_r,sd=0.01,diag=-0.5),rmatrix(nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r,sd=0.01)), "Beta_pr"=rbind(diag(TmbData$n_r),rmatrix(nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r,sd=0.2)), "logsigma_pz"=matrix(0,nrow=TmbData$n_p,2), "logF_ktp"=array(-20,dim=unlist(TmbData[c('n_k','n_t','n_p')])), "d_ktp"=array(0,dim=c(TmbData$n_k,TmbData$n_t,TmbData$n_p)), "Ainput_kp"=matrix(0,nrow=TmbData$n_k,ncol=TmbData$n_p), "delta_i"=rep(0,TmbData$n_i))      # "d_ktp"=array(2,dim=unlist(Data[c('n_k','n_t','n_p')]))

    # Random
    if( length(Random)==1 && Random=="generate" ){
      # Treating alpha_p, phi_p and B_pp as random (in REML) results in very slow inner optimization!  (100s of steps)
      Random = c( "Ainput_kp", "d_ktp" )
      if( "delta_i" %in% names(TmbParams)) Random = c(Random, "delta_i")
      if( "logF_ktp" %in% names(TmbParams)) Random = c(Random, "logF_ktp")
      if(use_REML==TRUE) Random = c(Random, "alpha_p", "phi_p")  # , "B_pp"
    }

    # Map
    if( length(Map)==1 && Map=="generate" ){
      Map = NULL
      # Anisotropy
      Map[["Hinput_z"]] = factor( rep(NA,2) )
      # Observation model
      Map[["logsigma_pz"]] = matrix( 1:(2*TmbData$n_p), ncol=2, byrow=TRUE )
      Map[["delta_i"]] = 1:TmbData$n_i
      for(p in 1:TmbData$n_p){
        if( TmbData$ObsModel_p[p]==0 ){
          Map[["logsigma_pz"]][p,] = c(NA,NA)
          if( "delta_i" %in% names(TmbParams) ) Map[["delta_i"]][which((TmbData$p_i+1)==p)] = rep(NA,sum((TmbData$p_i+1)==p))
        }
        if( TmbData$ObsModel_p[p]==1 ){
          Map[["logsigma_pz"]][p,2] = NA
          if( "delta_i" %in% names(TmbParams) ) Map[["delta_i"]][which((TmbData$p_i+1)==p)] = rep(NA,sum((TmbData$p_i+1)==p))
        }
        if( TmbData$ObsModel_p[p]==2 ){
          if( "delta_i" %in% names(TmbParams) ) Map[["delta_i"]][which((TmbData$p_i+1)==p)] = rep(NA,sum((TmbData$p_i+1)==p))
          # Check number of zeros (uses either c_i or b_i, whichever is available)
          NumZero = tapply( unlist(TmbData[c('c_i','b_i')]), INDEX=TmbData$p_i, FUN=function(vec){sum(vec==0)})
          if( any(NumZero==0) ){
            Map[["logsigma_pz"]][,2] = ifelse( NumZero==0, NA, Map[["logsigma_pz"]][,2])
            TmbParams[["logsigma_pz"]][,2] = ifelse( NumZero==0, 20, TmbParams[["logsigma_pz"]][,2])
          }
        }
        if( TmbData$ObsModel_p[p]==3 ){
          Map[["logsigma_pz"]][p,2] = NA
        }
        if( TmbData$ObsModel_p[p]==4 ){
          Map[["logsigma_pz"]][p,2] = NA
          if( "delta_i" %in% names(TmbParams) ) Map[["delta_i"]][which((TmbData$p_i+1)==p)] = rep(NA,sum((TmbData$p_i+1)==p))
        }
      }
      Map[["logsigma_pz"]] = factor( Map[["logsigma_pz"]] )
      Map[["delta_i"]] = factor( Map[["delta_i"]] )
      # Fix Alpha_pr and Beta_pr for the eigendecomposition method
      if( TmbData$Options_vec[["B_type"]] %in% c(1) ){
        # Alpha_pr, fix first row at one, so that the magnitude of each eigenvector is not colinear with the eigenvalues
        Map[["Alpha_pr"]] = array(1:prod(dim(TmbParams[["Beta_pr"]])), dim=dim(TmbParams[["Beta_pr"]]))
        Map[["Alpha_pr"]][1,] = NA
        Map[["Alpha_pr"]] = factor(Map[["Alpha_pr"]])
        # Beta_pr, just estimate row column, which is interpreted as eigenvalues
        Map[["Beta_pr"]] = array(NA, dim=dim(TmbParams[["Beta_pr"]]))
        Map[["Beta_pr"]][1,] = 1:ncol(Map[["Beta_pr"]])
        Map[["Beta_pr"]] = factor(Map[["Beta_pr"]])
        TmbParams[["Alpha_pr"]] = array( ifelse(!is.na(Map[["Alpha_pr"]]),TmbParams[["Alpha_pr"]],1), dim=dim(TmbParams[["Alpha_pr"]]))
        TmbParams[["Beta_pr"]] = array( ifelse(!is.na(Map[["Beta_pr"]]),-0.5,0), dim=dim(TmbParams[["Beta_pr"]]))  # B = U%*%L%*%solve(U) + I_pp, so -1<=eigenvalues<=0
      }
      # Identifiability restrictions on Beta_pr for co-integration method
      if( "Beta_pr"%in%names(TmbParams) && TmbData$Options_vec[["B_type"]]%in%c(0,2,4) ){
        Map[["Beta_pr"]] = factor(rbind( matrix(NA,nrow=TmbData$n_r,ncol=TmbData$n_r), matrix(seq_pos(TmbData$n_r*(TmbData$n_p-TmbData$n_r)),nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r)))
      }
      if( "Beta_pr"%in%names(TmbParams) && TmbData$Options_vec[["B_type"]]%in%c(3) ){
        Map[["Beta_pr"]] = rbind( matrix(NA,nrow=TmbData$n_r,ncol=TmbData$n_r), matrix(seq_pos(TmbData$n_r*(TmbData$n_p-TmbData$n_r)),nrow=TmbData$n_p-TmbData$n_r,ncol=TmbData$n_r))
        Map[["Beta_pr"]][cbind(1:TmbData$n_r,1:TmbData$n_r)] = max(Map[["Beta_pr"]],0,na.rm=TRUE) + 1:TmbData$n_r
        Map[["Beta_pr"]] = factor(Map[["Beta_pr"]])
        TmbParams[["Beta_pr"]][cbind(1:TmbData$n_r,1:TmbData$n_r)] = seq(-0.7,-0.3,length=TmbData$n_r) # Spread out eigenvalues
      }
      # Better initial conditions for eigen-cointegration
      if( "Alpha_pr"%in%names(TmbParams) && TmbData$Options_vec[["B_type"]]%in%c(2) && Version%in%c("spatial_vam_v11") ){
        TmbParams[["Alpha_pr"]][1,] = -0.5
      }
      if( "Alpha_pr"%in%names(TmbParams) && TmbData$Options_vec[["B_type"]]%in%c(3) ){
        TmbParams[["Alpha_pr"]][] = 0.1 * rnorm(prod(dim(TmbParams[["Alpha_pr"]])))
      }
      # Fix alpha if desired
      if( TmbData$Options_vec['IncludeAlpha']==0 ){
        Map[["Ainput_kp"]] = factor( array(NA,dim=dim(TmbParams[["Ainput_kp"]])) )
        Map[["logtauA_p"]] = factor(NA)
      }
      # fix phi
      if( estimate_phi==FALSE ){
        Map[["phi_p"]] = factor( rep(NA,length(TmbParams[["phi_p"]])) )
        TmbParams[["phi_p"]][] = 0
      }
      # Make B_pp diagonal
      if( TmbData$Options_vec[["independentTF"]]==TRUE ){
        if( "B_pp" %in% names(TmbParams) ){
          Map[["B_pp"]] = matrix(NA, nrow=TmbData$n_p, ncol=TmbData$n_p)
          diag(Map[["B_pp"]]) = 1:TmbData$n_p
          Map[["B_pp"]] = factor( Map[["B_pp"]] )
          TmbParams[["B_pp"]][] = 0
          TmbParams[["L_val"]][] = 0
        }
        if( "Alpha_pr"%in%names(TmbParams) && TmbData$n_r==TmbData$n_p ){
          Map[["Alpha_pr"]] = matrix(NA, nrow=TmbData$n_p, ncol=TmbData$n_p)
          diag(Map[["Alpha_pr"]]) = 1:TmbData$n_p
          Map[["Alpha_pr"]] = factor( Map[["Alpha_pr"]] )
          TmbParams[["Alpha_pr"]][] = 0
          TmbParams[["L_val"]][] = 0
        }
        TmbParams[["L_val"]] = TmbParams[["L_val"]][1:TmbData$n_p]
      }
      # Fix logkappa_z at shared value by default
      if( Kappa=="constant" ){
        if("logkappa_z" %in% names(TmbParams)) Map[['logkappa_z']] = factor( rep(1,length(TmbParams[["logkappa_z"]])) )
      }
      if( Kappa=="spatial_vs_spatiotemporal" ){
        if("logkappa_z" %in% names(TmbParams)) Map[['logkappa_z']] = factor( c(rep(1,TmbData$n_p),2) )
      }
      # Fix logF_ktp for years without harvest, and change starting values to be appropriate
      if( "logF_ktp" %in% names(TmbParams)){
        if( TmbData[["Options_vec"]]["Harvest_Method"]%in%c(0,1,3) ){
          Map[["logF_ktp"]] = factor( rep(NA,prod(unlist(TmbData[c('n_k','n_t','n_p')]))) )
        }
        if( TmbData[["Options_vec"]]["Harvest_Method"]%in%c(2,4) ){
          Map[["logF_ktp"]] = array( 1:prod(unlist(TmbData[c('n_k','n_t','n_p')])), dim=unlist(TmbData[c('n_k','n_t','n_p')]) )
          Map[["logF_ktp"]] = ifelse( TmbData[['c_ktp']]==0, NA, Map[["logF_ktp"]] )
          Map[["logF_ktp"]] = factor(Map[["logF_ktp"]])
          TmbParams[["logF_ktp"]] = ifelse( TmbData[['c_ktp']]==0, -20, -1 )
        }
      }
    }

    # Decide about user-supplied or generated Parameters
    if( length(Parameters)==1 && Parameters=="generate" ){
      Parameters = TmbParams
    }else{
      if( length(unlist(Parameters))!=length(unlist(TmbParams)) ) stop("`Parameters` input is wrong length")
    }
  } # End spatial
  
  # Build object
  dyn.load( paste0(RunDir,"/",TMB::dynlib(Version)) ) # random=Random,
  Obj <- MakeADFun(data=TmbData, parameters=Parameters, hessian=FALSE, map=Map, random=Random, inner.method="newton", DLL=Version)  #
  Obj$control <- list(trace=1, parscale=1, REPORT=1, reltol=1e-12, maxit=100)

  # Bounds
  Upper = rep(Inf, length(Obj$par) )
    if( TmbData$Options_vec[1] %in% c(1) ) Upper[grep("Beta_pr",names(Obj$par))] = eigenbounds['Upper']
    if( TmbData$Options_vec[1] %in% c(2) ) Upper[grep("Alpha_pr",names(Obj$par))[1+TmbData$n_p*0:TmbData$n_r]] = eigenbounds['Upper']
    if( TmbData$Options_vec[1] %in% c(3) ) Upper[grep("Beta_pr",names(Obj$par))[length(grep("Beta_pr",names(Obj$par)))-TmbData$n_r:1+1]] = eigenbounds['Upper']
    if( TmbData$Options_vec[["independentTF"]]==TRUE ) Upper[grep("Alpha_pr",names(Obj$par))] = EigenBounds['Upper']
  Lower = rep(-Inf, length(Obj$par) )
    if( TmbData$Options_vec[1] %in% c(1) ) Lower[grep("Beta_pr",names(Obj$par))] = eigenbounds['Lower']
    if( TmbData$Options_vec[1] %in% c(2) ) Lower[grep("Alpha_pr",names(Obj$par))[1+TmbData$n_p*0:TmbData$n_r]] = eigenbounds['Lower']
    if( TmbData$Options_vec[1] %in% c(3) ) Lower[grep("Beta_pr",names(Obj$par))[length(grep("Beta_pr",names(Obj$par)))-TmbData$n_r:1+1]] = eigenbounds['Lower']
    if( TmbData$Options_vec[["independentTF"]]==TRUE ) Lower[grep("Alpha_pr",names(Obj$par))] = EigenBounds['Lower']
    Lower[grep("logMargSigmaA_p",names(Obj$par))] = log(0.01)

  # Bounds on distances
  if( length(grep("logkappa",names(Obj$par)))>0 && !is.na(TmbData$Options_vec['Spatial_Method']) && TmbData$Options_vec['Spatial_Method']==0 ){
    Lower[grep("logkappa",names(Obj$par))] = MinDist # Range = nu*sqrt(8)/kappa
    Upper[grep("logkappa",names(Obj$par))] = MaxDist # Range = nu*sqrt(8)/kappa
  }

  # Change convergence tolerance
  #Obj$env$inner.control$step.tol <- c(1e-8,1e-12,1e-15)[ConvergeTol] # Default : 1e-8  # Change in parameters limit inner optimization
  #Obj$env$inner.control$tol10 <- c(1e-6,1e-8,1e-12)[ConvergeTol]  # Default : 1e-3     # Change in pen.like limit inner optimization
  #Obj$env$inner.control$grad.tol <- c(1e-8,1e-12,1e-15)[ConvergeTol] # # Default : 1e-8  # Maximum gradient limit inner optimization

  # Print number of parameters
  message("Number of fixed and random effects:")
  print( table(names(Obj$env$last.par)) )

  # Return stuff
  Return = list("Obj"=Obj, "Upper"=Upper, "Lower"=Lower, "Parameters"=Parameters, "Map"=Map, "Random"=Random )
  return(Return)
}
